#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}%
 \renewcommand{\sectionautorefname}{\negthinspace}%
 \renewcommand{\subsectionautorefname}{\negthinspace}%
 \renewcommand{\subsubsectionautorefname}{\negthinspace}%
 \renewcommand{\figureautorefname}{Fig.\negthinspace}%
 \renewcommand{\tableautorefname}{Tab.\negthinspace}%
}
\@ifpackageloaded{babel}{\addto\extrasitalian{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% enables graph drawing
\usepackage{tikz}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams-bytype
theorems-chap-bytype
\end_modules
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Documento > Proprietà PDF > Generale"
\pdf_author "Francesco Marano"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Algoritmo di pianificazione
\begin_inset CommandInset label
LatexCommand label
name "chap:algoritmo-di-pianificazione"

\end_inset


\end_layout

\begin_layout Standard
In questo capitolo verranno presentati in dettaglio i diversi elementi che
 permettono di rappresentare un problema di pianificazione rispetto al mondo
 presentato.
 Per raggiungere questo risultato e automatizzare il processo di ricerca
 della soluzione, è stato sviluppato un nuovo algoritmo sulla base del ben
 più noto algoritmo di pianificazione GraphPlan 
\begin_inset CommandInset citation
LatexCommand cite
key "publication:GraphPlan"

\end_inset

, sviluppato da Avrim Blum e Merrick Furst nel 1995, di cui costituisce
 un rilassamento.
\end_layout

\begin_layout Standard
Chiameremo questo algoritmo RGP
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "RGP"
description "Relaxed GraphPlan"

\end_inset

 da 
\shape italic

\begin_inset Quotes fld
\end_inset

Relaxed GraphPlan
\shape default

\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Standard
Nel paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:relaxed-graphplan"

\end_inset

 verranno esposti in dettaglio tutti gli elementi che costituiscono la struttura
 dati utilizzata da RGP, in particolare: l'istanza del problema (
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:istanza-del-problema"

\end_inset

), il grafo di pianificazione (
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:grafo-di-pianificazione"

\end_inset

), la soluzione del problema (
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:soluzione"

\end_inset

).
\end_layout

\begin_layout Standard
Nel paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:descrizione-implementativa"

\end_inset

 verrà fornita una descrizione implementativa di RGP attraverso sia spiegazioni
 che pseudocodice delle funzioni che costituiscono il cuore dell'algoritmo;
 in particolare verranno illustrati: la costruzione del grafo di pianificazione
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:costruzione-grafo-pianificazione"

\end_inset

), l'espansione del grafo (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:espansione-del-grafo"

\end_inset

), l'estrazione della soluzione (
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:estrazione-della-soluzione"

\end_inset

).
\end_layout

\begin_layout Standard
Nel paragrafo 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:proprietà"

\end_inset

 verranno infine mostrate le proprietà del grafo risultante l'esecuzione
 di RGP nonché la terminazione, completezza e complessità dell'algoritmo
 stesso.
\end_layout

\begin_layout Section
Relaxed GraphPlan
\begin_inset CommandInset label
LatexCommand label
name "sec:relaxed-graphplan"

\end_inset


\end_layout

\begin_layout Standard
RGP è un algoritmo di pianificazione per la ricerca automatica di pattern
 di esecuzione dei componenti al fine di raggiungere lo stato finale specificato.
\end_layout

\begin_layout Standard
L'algoritmo riceve in input un problema di pianificazione espresso in forma
 di insieme di proprietà iniziali e proprietà finali e produce, laddove
 possibile, una sequenza di azioni la cui esecuzione porta al raggiungimento
 dello stato finale.
\end_layout

\begin_layout Standard
Nel grafo risultante dalla costruzione di un'istanza del problema:
\end_layout

\begin_layout Itemize
i nodi sono proprietà e azioni eseguibili, disposte in un'alternanza di
 livelli
\end_layout

\begin_layout Itemize
gli archi sono di due tipi:
\end_layout

\begin_deeper
\begin_layout Itemize
da una proprietà alle azioni di cui è precondizione,
\end_layout

\begin_layout Itemize
da un'azione alla proprietà che ha come postcondizione.
\end_layout

\end_deeper
\begin_layout Standard
Il primo livello contiene le proprietà che identificano lo stato iniziale
 che può eventualmente essere vuoto.
 L'ultimo livello contiene le proprietà che identificano lo stato finale.
\end_layout

\begin_layout Standard
L'algoritmo iterativamente espande il grafo, verificando che non sia già
 stato raggiunto lo stato finale prima di procedere; durante l'espansione
 RGP cerca, sulla base delle proprietà fino a quel momento ottenute, tutte
 quelle proprietà le cui precondizioni risultano soddisfatte, e che non
 siano già state inserite nel grado, e le utilizza per costruire il livello
 successivo.
\end_layout

\begin_layout Subsection
Istanza del problema
\begin_inset CommandInset label
LatexCommand label
name "sec:istanza-del-problema"

\end_inset


\end_layout

\begin_layout Standard
In RGP un'istanza del problema è una tripla 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 è l'insieme delle azioni
\end_layout

\begin_layout Itemize
\begin_inset Formula $s_{i}$
\end_inset

 è l'insieme delle proprietà che costituiscono lo stato iniziale
\end_layout

\begin_layout Itemize
\begin_inset Formula $g$
\end_inset

 è l'insieme delle proprietà che costituiscono lo stato finale
\end_layout

\begin_layout Subsection
Grafo di pianificazione
\begin_inset CommandInset label
LatexCommand label
name "sec:grafo-di-pianificazione"

\end_inset


\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 un'istanza di RGP, allora 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 è il corrispondente grafo di pianificazione, dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V=P_{0}\cup A_{1}\cup P_{1}\cup\ldots\cup A_{n}\cup P_{n}$
\end_inset

 con:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $P_{0}\equiv s_{i}$
\end_inset

, lo stato iniziale
\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{n}\equiv g$
\end_inset

, lo stato finale
\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{i}=\left\{ p\colon p\in P_{i-1}\right\} \cup\left\{ p\colon\exists a\in A_{i}\left[p=postcondition(a)\right]\right\} $
\end_inset

, l'insieme delle proprietà al livello 
\begin_inset Formula $i$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $A_{j}=\left\{ a\colon preconditions(a)\subseteq P_{j-1}\right\} $
\end_inset

, l'insieme delle azioni al livello 
\begin_inset Formula $j$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $E=E_{pre}\cup E_{post}$
\end_inset

 con:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $E_{pre}=\left\{ (p,a)\colon p\in P_{i-1},a\in A_{i}\left[p\in preconditions(a)\right]\right\} $
\end_inset

 per 
\begin_inset Formula $i\in\left\{ 1,\ldots,n\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{post}=\left\{ (a,p)\colon a\in A_{i},p\in P_{i}\left[p=postcondition(a)\right]\right\} $
\end_inset

 per 
\begin_inset Formula $i\in\left\{ 1,\ldots,n\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Proposition
Ad ogni passo dell'algoritmo deve essere vero che, comunque presi due indici
 
\begin_inset Formula $i$
\end_inset

 e 
\begin_inset Formula $j$
\end_inset

 tali che 
\begin_inset Formula $i\neq j$
\end_inset

 e 
\begin_inset Formula $i,j<n$
\end_inset

, allora 
\begin_inset Formula $a\in A_{i}\implies a\notin A_{j}$
\end_inset

.
\end_layout

\begin_layout Definition
Il risultato dell'applicazione dell'insieme di azioni 
\begin_inset Formula $\alpha$
\end_inset

 allo stato 
\begin_inset Formula $s$
\end_inset

 è definito come:
\begin_inset Formula 
\[
\rho\left(s,\alpha\right)=s\cup postconditions\left(\alpha\right)
\]

\end_inset

 dove:
\begin_inset Formula 
\[
postconditions\left(\alpha\right)=\bigcup_{a\in\alpha}postcondition\left(a\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Remark
Un insieme di azioni 
\begin_inset Formula $\alpha$
\end_inset

 è applicabile a uno stato 
\begin_inset Formula $s$
\end_inset

 se e solo se 
\begin_inset Formula $\bigcup_{a\in\alpha}preconditions(a)\subseteq s$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Proposition
Dato un insieme di azioni 
\begin_inset Formula $\alpha$
\end_inset

 in uno stato 
\begin_inset Formula $s$
\end_inset

 allora, per ogni permutazione 
\begin_inset Formula $\sigma=<a_{1},\ldots,a_{k}>$
\end_inset

 degli elementi di 
\begin_inset Formula $\alpha$
\end_inset

:
\end_layout

\begin_layout Itemize
la sequenza 
\begin_inset Formula $\sigma$
\end_inset

 è applicabile a 
\begin_inset Formula $s$
\end_inset


\end_layout

\begin_layout Itemize
lo stato risultante dall'applicazione di 
\begin_inset Formula $\alpha$
\end_inset

 è lo stesso di quello derivante dall'applicazione di 
\begin_inset Formula $\sigma$
\end_inset

, cioè 
\begin_inset Formula $\rho\left(s,\alpha\right)=\rho\left(s,\sigma\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Soluzione
\begin_inset CommandInset label
LatexCommand label
name "sec:soluzione"

\end_inset


\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 un'istanza di RGP e 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 il corrispondente grafo di pianificazione.
\end_layout

\begin_layout Definition
Due azioni 
\begin_inset Formula $a_{1}$
\end_inset

 e 
\begin_inset Formula $a_{2}$
\end_inset

 sono equivalenti se e solo se 
\begin_inset Formula $postcondition\left(a_{1}\right)=postcondition\left(a_{2}\right)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Due azioni 
\begin_inset Formula $a_{1}$
\end_inset

 e 
\begin_inset Formula $a_{2}$
\end_inset

 sono identiche se sono equivalenti e 
\begin_inset Formula $preconditions\left(a_{1}\right)=preconditions\left(a_{2}\right)$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Un 
\shape italic
layered plan
\shape default
 su 
\begin_inset Formula $G$
\end_inset

 è una sequenza di insiemi di azioni definita come:
\begin_inset Formula 
\[
\Pi=<\pi_{1},\ldots,\pi_{k}>
\]

\end_inset

dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{i}\subseteq A_{i}\subseteq A$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{i}$
\end_inset

 è applicabile nello stato 
\begin_inset Formula $P_{i-1}$
\end_inset


\end_layout

\begin_layout Itemize
le azioni in 
\begin_inset Formula $\pi_{i}$
\end_inset

 sono non-identiche e non-equivalenti
\end_layout

\begin_layout Theorem
Un layered plan 
\begin_inset Formula $\Pi=<\pi_{1},\ldots,\pi_{k}>$
\end_inset

 è una soluzione di un'istanza di RGP 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 se e solo se:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{1}$
\end_inset

 è applicabile in 
\begin_inset Formula $s_{i}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall j\in\left\{ 2,\ldots,k\right\} $
\end_inset

 
\begin_inset Formula $\pi_{j}$
\end_inset

 è applicabile nello stato 
\begin_inset Formula $\rho\left(\ldots\rho\left(\rho\left(s_{i},\pi_{1}\right),\pi_{2}\right)\ldots,\pi_{j-1}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $g\subseteq\rho\left(\ldots\rho\left(\rho\left(s_{i},\pi_{1}\right),\pi_{2}\right)\ldots,\pi_{k}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Proposition
Se 
\begin_inset Formula $\Pi=<\pi_{1},\ldots,\pi_{k}>$
\end_inset

 è una soluzione di un'istanza di RGP 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

, allora 
\begin_inset Formula $\forall j\in\left\{ 1,\ldots,k\right\} $
\end_inset

 una sequenza di azioni corrispondenti a qualsiasi permutazione degli elementi
 di 
\begin_inset Formula $\pi_{j}$
\end_inset

 è un percorso da 
\begin_inset Formula $s_{i}$
\end_inset

 a 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Section
Descrizione implementativa
\begin_inset CommandInset label
LatexCommand label
name "sec:descrizione-implementativa"

\end_inset


\end_layout

\begin_layout Subsection
Costruzione del grafo di pianificazione
\begin_inset CommandInset label
LatexCommand label
name "sub:costruzione-grafo-pianificazione"

\end_inset


\end_layout

\begin_layout Standard
A partire dallo stato iniziale l'algoritmo iterativamente espande il grafo.
 A ogni passo si possono verificare tre condizioni:
\end_layout

\begin_layout Enumerate
è stato raggiunto lo stato finale.
 L'algoritmo estrae la soluzione dal grafo trovato e termina.
\end_layout

\begin_layout Enumerate
non è stato raggiunto lo stato finale, ma è ancora possibile trovare una
 soluzione.
 L'algoritmo procede espandendo il grafo.
\end_layout

\begin_layout Enumerate
non è stato raggiunto lo stato finale e non è possibile farlo tramite ulteriori
 espansioni.
 L'algoritmo termina in uno stato di 
\shape italic
failure
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
costruzione del grafo di pianificazione
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
function
\series default
 RelaxedGraphPlan(
\begin_inset Formula $A$
\end_inset

,
\begin_inset Formula $s_{i}$
\end_inset

,
\begin_inset Formula $g$
\end_inset

)
\end_layout

\begin_layout LyX-Code

\series bold
returns
\series default
 LayeredPlan, or failure
\end_layout

\begin_deeper
\begin_layout LyX-Code
graph 
\begin_inset Formula $\leftarrow$
\end_inset

 initialPlanningGraph(
\begin_inset Formula $s_{i}$
\end_inset

)
\end_layout

\begin_layout LyX-Code
goals 
\begin_inset Formula $\leftarrow$
\end_inset

 
\begin_inset Formula $g$
\end_inset


\end_layout

\begin_layout LyX-Code
\noindent

\series bold
loop do
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\noindent

\series bold
if
\series default
 goals all in last property layer of graph 
\series bold
then
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
return
\series default
 LayeredPlan(graph, goals)
\end_layout

\end_deeper
\begin_layout LyX-Code

\series bold
else if
\series default
 noSolutionPossible(graph, goals) 
\series bold
then
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
return
\series default
 failure
\end_layout

\end_deeper
\begin_layout LyX-Code

\series bold
else
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single
\noindent
graph 
\begin_inset Formula $\leftarrow$
\end_inset

 expand(graph, 
\begin_inset Formula $A$
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Subsection
Espansione del grafo
\begin_inset CommandInset label
LatexCommand label
name "sub:espansione-del-grafo"

\end_inset


\end_layout

\begin_layout Definition
Indichiamo con 
\begin_inset Formula $G_{k}=\left(V_{k},E_{k}\right)$
\end_inset

 il grafo di pianificazione ottenuto al passo 
\begin_inset Formula $k$
\end_inset

, dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V_{k}=P_{0}\cup P_{1}\cup A_{1}\cup\ldots\cup P_{k}\cup A_{k}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{k}=E_{pre}^{k}\cup E_{post}^{k}$
\end_inset

 con:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $E_{pre}^{k}=\left\{ (p,a)\colon p\in P_{k-1},a\in A_{k}\left[p\in preconditions(a)\right]\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{post}^{k}=\left\{ (a,p)\colon a\in A_{k},p\in P_{k}\left[p=postcondition(a)\right]\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
In un generico istante 
\begin_inset Formula $k$
\end_inset

 l'algoritmo di espansione del grafo di pianificazione trova prima di tutto
 l'insieme 
\begin_inset Formula $A_{k}$
\end_inset

 delle azioni, che non facciano già parte di alcun livello precedente, le
 cui precondizioni risultino soddisfatte dalle proprietà fino a quel momento
 ottenute.
\end_layout

\begin_layout Standard
A partire da queste si ottiene il livello delle proprietà 
\begin_inset Formula $P_{k}$
\end_inset

 successivo costituito di tutte le proprietà del livello precedente più
 quelle ottenute dalle postcondizioni delle azioni in 
\begin_inset Formula $A_{k}$
\end_inset

.
\end_layout

\begin_layout Standard
A questo punto viene completato il grafo inserendo gli archi tra le proprietà
 del livello precedente verso le azioni che le richiedono come precondizioni,
 e quelli tra le azioni del livello attuale verso le proprietà che hanno
 come postcondizioni.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
espansione del grafo di pianificazione
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
function
\series default
 expand(
\begin_inset Formula $G_{k-1}$
\end_inset

,
\begin_inset Formula $A$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $A_{k}\leftarrow\left\{ a\in A\colon a\notin A_{j=1,\ldots,k-1}\land preconditions\left(a\right)\subseteq P_{k-1}\right\} $
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $P_{k}\leftarrow\left\{ p\colon\exists a\in A_{k}\left[p=postcondition\left(a\right)\right]\right\} \cup P_{k-1}$
\end_inset


\end_layout

\begin_layout LyX-Code
foreach 
\begin_inset Formula $a$
\end_inset

 in 
\begin_inset Formula $A_{k}$
\end_inset

 do:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
\begin_inset Formula $E_{pre}^{k}\leftarrow E_{pre}^{k-1}\cup\left\{ \left(p,a\right)\colon p\in P_{k-1}\land p\in preconditions\left(a\right)\right\} $
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\size small
\begin_inset Formula $E_{post}^{k}\leftarrow E_{post}^{k-1}\cup\left\{ \left(a,p\right)\colon p\in P_{k}\land p=postcondition\left(a\right)\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement h
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
def
\backslash
layersep{2cm}
\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[shorten >=1pt,->,draw=black!50, node distance=
\backslash
layersep]
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{every pin edge}=[<-,shorten <=1pt]
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{neuron}=[circle,fill=black!25,minimum size=17pt,inner sep=0pt]
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{input neuron}=[neuron, fill=green!20];
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{output neuron}=[neuron, fill=red!20];
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{action neuron}=[neuron, fill=orange!20];
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{property neuron}=[neuron, fill=gray!20];
\end_layout

\begin_layout Plain Layout

	
\backslash
tikzstyle{annot}=[text width=4em, text centered, node distance=1cm];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Draw the framebox for the action-property layer couples
\end_layout

\begin_layout Plain Layout

	
\backslash
put(-10,-140){
\backslash
framebox(20,140)};
\end_layout

\begin_layout Plain Layout

	
\backslash
put(45,-140){
\backslash
framebox(80,140)};
\end_layout

\begin_layout Plain Layout

	
\backslash
put(160,-140){
\backslash
framebox(80,140)};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    % Draw the action and property layer nodes
\end_layout

\begin_layout Plain Layout

	% Property layer 0
\end_layout

\begin_layout Plain Layout

	
\backslash
path[yshift=0.5cm]
\end_layout

\begin_layout Plain Layout

		node[input neuron, pin={left:Input}] (P0-1) at (0,-1) {p1};
\end_layout

\begin_layout Plain Layout

	% Action layer 1
\end_layout

\begin_layout Plain Layout

	
\backslash
foreach 
\backslash
name / 
\backslash
y in {1,...,3}
\end_layout

\begin_layout Plain Layout

		
\backslash
path[yshift=0.5cm]
\end_layout

\begin_layout Plain Layout

			node[action neuron] (A1-
\backslash
y) at (1*
\backslash
layersep,-
\backslash
y) {a
\backslash
name};
\end_layout

\begin_layout Plain Layout

	% Property layer 1
\end_layout

\begin_layout Plain Layout

	
\backslash
foreach 
\backslash
name / 
\backslash
y in {1,...,3}
\end_layout

\begin_layout Plain Layout

		
\backslash
path[yshift=0.5cm]
\end_layout

\begin_layout Plain Layout

			node[property neuron] (P1-
\backslash
y) at (2*
\backslash
layersep,-
\backslash
y) {p
\backslash
name};
\end_layout

\begin_layout Plain Layout

	% Action layer 2
\end_layout

\begin_layout Plain Layout

	
\backslash
foreach 
\backslash
y [count=
\backslash
name from 4] in {1,...,4}
\end_layout

\begin_layout Plain Layout

		
\backslash
path[yshift=0.5cm]
\end_layout

\begin_layout Plain Layout

			node[action neuron] (A2-
\backslash
y) at (3*
\backslash
layersep,-
\backslash
y cm) {a
\backslash
name};
\end_layout

\begin_layout Plain Layout

	% Property layer 2
\end_layout

\begin_layout Plain Layout

	
\backslash
foreach 
\backslash
name / 
\backslash
y in {1,...,5}
\end_layout

\begin_layout Plain Layout

		
\backslash
path[yshift=0.5cm]
\end_layout

\begin_layout Plain Layout

			node[output neuron, pin={[pin edge={->}]right:Output}] (P2-
\backslash
y) at (4*
\backslash
layersep,-
\backslash
y) {p
\backslash
name};
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
path (P0-1) edge (A1-1);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P0-1) edge (A1-2);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A1-1) edge (P1-2);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A1-2) edge (P1-2);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A1-3) edge (P1-3);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P1-1) edge (A2-1);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P1-2) edge (A2-1);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P1-2) edge (A2-2);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P1-2) edge (A2-3);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P1-3) edge (A2-3);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (P1-3) edge (A2-4);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A2-1) edge (P2-4);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A2-2) edge (P2-4);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A2-3) edge (P2-5);
\end_layout

\begin_layout Plain Layout

	
\backslash
path (A2-4) edge (P2-5);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	% Annotate the layers
\end_layout

\begin_layout Plain Layout

	
\backslash
node[annot,above of=P0-1] {P0};
\end_layout

\begin_layout Plain Layout

	
\backslash
node[annot,above of=A1-1] {A1};
\end_layout

\begin_layout Plain Layout

	
\backslash
node[annot,above of=P1-1] {P1};
\end_layout

\begin_layout Plain Layout

	
\backslash
node[annot,above of=A2-1] {A2};
\end_layout

\begin_layout Plain Layout

	
\backslash
node[annot,above of=P2-1] {P2};
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture}
\end_layout

\end_inset


\begin_inset Caption Below

\begin_layout Plain Layout

\size small
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\size normal
Grafo di pianificazione risultante dall'esecuzione di RGP
\end_layout

\end_inset


\size footnotesize
La figura mostra un semplice esempio di grafo risultante dall'esecuzione
 di RGP.
 In questo caso l'input dato dall'utente è il valore di una singola proprietà
 (
\shape italic
p1
\shape default
).
 Quando il grafo viene espanso vengono aggiunte 3 azioni, 2 delle quali
 (
\shape italic
a1
\shape default
, 
\shape italic
a2
\shape default
) dipendenti da 
\shape italic
p1
\shape default
, l'ultima (
\shape italic
a3
\shape default
) in grado di essere eseguita senza alcuna proprietà iniziale.
 Sia 
\shape italic
a1
\shape default
 che 
\shape italic
a2
\shape default
 forniscono la stessa proprietà (
\shape italic
p2
\shape default
) in uscita, mentre 
\shape italic
a3
\shape default
 fornisce 
\shape italic
p3
\shape default
; 
\shape italic
p1
\shape default
 viene replicata in modo che ogni livello possa esporre l'intero stato delle
 proprietà per la costruzione del livello successivo.
 L'espansione del grafo si ripete fino al raggiungimento dello stato finale
 indicato dall'utente (qualora sia possibile raggiungerlo).
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Estrazione della soluzione
\begin_inset CommandInset label
LatexCommand label
name "sub:estrazione-della-soluzione"

\end_inset


\end_layout

\begin_layout Standard
L'estrazione della soluzione procede iterativamente dall'ultimo verso il
 primo dei livelli del grafo di pianificazione.
 A ogni passo 
\begin_inset Formula $i$
\end_inset

, trova un insieme di azioni 
\begin_inset Formula $\alpha_{i}\subseteq A_{i}$
\end_inset

 tali che lo stato finale 
\begin_inset Formula $g$
\end_inset

 sia soddisfatto, cioè 
\begin_inset Formula $\bigcup_{a\in\alpha_{i}}postcondition\left(a\right)=g$
\end_inset

, e si inseriscono nella soluzione.
\end_layout

\begin_layout Standard
A questo punto si prende l'unione di tutte le precondizioni delle azioni
 scelte e si imposta come nuovo stato finale, cioè 
\begin_inset Formula $g=\bigcup_{a\in\alpha_{i}}preconditions\left(a\right)$
\end_inset

, e si procede con il prossimo livello.
\end_layout

\begin_layout Standard
Raggiunto il primo livello (lo stato iniziale), l'algoritmo termina restituendo
 la soluzione.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
estrazione della soluzione
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
function
\series default
 LayeredPlan(planning graph 
\begin_inset Formula $G$
\end_inset

, goal state 
\begin_inset Formula $g$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $solution$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset

 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
for
\series default
 
\begin_inset Formula $i=\left|G\right|$
\end_inset

 
\series bold
to
\series default
 
\begin_inset Formula $1$
\end_inset

 
\series bold
do
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $\alpha_{i}\leftarrow\left\{ a\colon a\in A_{i}\land postcondition\left(a\right)\in g\right\} $
\end_inset


\end_layout

\begin_layout LyX-Code
prepend 
\begin_inset Formula $\alpha_{i}$
\end_inset

 to 
\begin_inset Formula $solution$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $g\leftarrow\bigcup_{a\in\alpha_{i}}preconditions\left(a\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\series bold
return
\series default
 
\begin_inset Formula $solution$
\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout

\begin_layout Section
Proprietà
\begin_inset CommandInset label
LatexCommand label
name "sec:proprietà"

\end_inset


\end_layout

\begin_layout Definition
Un 
\shape italic
fixed-point level
\shape default
 in un grafo di pianificazione 
\begin_inset Formula $G$
\end_inset

 è un livello 
\begin_inset Formula $k$
\end_inset

 tale che comunque scelto un indice 
\begin_inset Formula $i>k$
\end_inset

, il livello 
\begin_inset Formula $i$
\end_inset

 del grafo 
\begin_inset Formula $G$
\end_inset

 è identico al livello 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "proposition:esistenza-fixed-point-level"

\end_inset

Ogni grafo di pianificazione 
\begin_inset Formula $G$
\end_inset

 ha un fixed-point level 
\begin_inset Formula $k$
\end_inset

, che è il più piccolo 
\begin_inset Formula $k$
\end_inset

 tale che 
\begin_inset Formula $\left|P_{k}\right|=\left|P_{k+1}\right|$
\end_inset


\end_layout

\begin_layout Proof
Se una proprietà appare in un qualche livello delle proprietà 
\begin_inset Formula $P_{i}$
\end_inset

, allora apparirà anche in tutti i livelli successivi (vedi Sottosezione
 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:espansione-del-grafo"

\end_inset

).
 Dato che:
\end_layout

\begin_deeper
\begin_layout Itemize
l'insieme delle azioni 
\begin_inset Formula $A$
\end_inset

 è un insieme finito
\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{j}$
\end_inset

 cresce monotonicamente
\end_layout

\begin_layout Itemize
\begin_inset Formula $A_{j}$
\end_inset

 e 
\begin_inset Formula $P_{j}$
\end_inset

 dipendono unicamente da 
\begin_inset Formula $P_{j-1}$
\end_inset


\end_layout

\begin_layout Standard
allora deve necessariamente esistere un livello delle azioni vuoto per cui
 il corrispondente livello delle proprietà non aggiungerà nuovi elementi
 e quindi tutti i livelli successivi avranno esattamente lo stesso insieme
 di proprietà.
\end_layout

\end_deeper
\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lemma:fixed-point-level-upperbound"

\end_inset

È sempre vero che 
\begin_inset Formula $k\leq\left|A\right|+1$
\end_inset

.
\end_layout

\begin_layout Proof
Durante la costruzione del grafo di pianificazione il caso peggiore si presenta
 quando:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $s_{i}=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $preconditions\left(a_{1}\right)=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall i=3,\ldots,\left|A\right|,postcondition\left(a_{i-1}\right)=preconditions\left(a_{i}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $g=postcondition\left(a_{\left|A\right|}\right)$
\end_inset


\end_layout

\begin_layout Standard
In questo caso a ogni espansione del grafo viene aggiunta solamente un'azione
 e la sua postcondizione; questo risulta in un unico percorso da 
\begin_inset Formula $s_{i}$
\end_inset

 a 
\begin_inset Formula $g$
\end_inset

 che passa attraverso 
\begin_inset Formula $\left|A\right|$
\end_inset

 livelli più quello iniziale vuoto.
\end_layout

\end_deeper
\begin_layout Subsection*
Terminazione
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "theorem:rgp-termination"

\end_inset

RGP termina sempre.
\end_layout

\begin_layout Proof
Dalla Proposizione 
\begin_inset CommandInset ref
LatexCommand ref
reference "proposition:esistenza-fixed-point-level"

\end_inset

 e dal Lemma 
\begin_inset CommandInset ref
LatexCommand ref
reference "lemma:fixed-point-level-upperbound"

\end_inset

 possiamo affermare che RGP termina sempre dopo al più 
\begin_inset Formula $k$
\end_inset

 espansioni del grafo di pianificazione.
\end_layout

\begin_layout Subsection*
Completezza
\end_layout

\begin_layout Theorem
RGP termina in uno stato di fallimento se e solo se il problema di pianificazion
e dato non ha soluzione.
\end_layout

\begin_layout Proof
La direzione più semplice della dimostrazione è che se il problema non ha
 soluzione, allora RGP terminerà in uno stato di fallimento.
 Questa affermazione è diretta conseguenza del fatto che se non esiste soluzione
 RGP continuerà l'espansione del grafo fino al raggiugimento del 
\emph on
fixed-point level
\emph default
, dopodiché terminerà (vedi Proposizione 
\begin_inset CommandInset ref
LatexCommand ref
reference "proposition:esistenza-fixed-point-level"

\end_inset

).
\end_layout

\begin_layout Proof
Per dimostrare la direzione opposta supponiamo per assurdo che il problema
 abbia soluzione, ma che RGP sia terminato in uno stato di fallimento.
\begin_inset Newline newline
\end_inset

Sappiamo per costruzione che RGP termina dopo l'espansione del grafo di
 pianificazione se trova la soluzione del problema, cioè lo stato finale
 è interamente contenuto nell'ultimo livello delle proprietà, oppure se
 ha raggiunto un 
\emph on
fixed-point level
\emph default
.
 Sappiamo RGP essere terminato in uno stato di fallimento, cioè ha raggiunto
 il 
\emph on
fixed-point level
\emph default
.
 Per definizione l'ultimo livello delle proprietà conterrà l'insieme 
\begin_inset Formula $S$
\end_inset

 di tutte le proprietà ottenibili a partire dallo stato iniziale specificato.
 Questo significa che 
\begin_inset Formula $S$
\end_inset

 contiene anche lo stato finale perché abbiamo supposto il problema risolvibile,
 ma questo è un assurdo.
\end_layout

\begin_layout Corollary
Se 
\begin_inset Formula $g$
\end_inset

 è raggiungibile da 
\begin_inset Formula $s_{i}$
\end_inset

 allora 
\begin_inset Formula $\exists P_{g}\colon g\subseteq P_{g}$
\end_inset


\end_layout

\begin_layout Subsection*
Complessità
\end_layout

\begin_layout Theorem
La dimensione del grafo di pianificazione fino al livello 
\begin_inset Formula $k$
\end_inset

 e il tempo richiesto per espanderlo fino a quel livello sono polinomiali
 nella dimensione del problema di pianificazione.
\end_layout

\begin_layout Proof
La dimostrazione della complessità di RGP è una conseguenza diretta di alcune
 sue proprietà, cioè:
\end_layout

\begin_deeper
\begin_layout Itemize
la dimensione del problema è 
\begin_inset Formula $n=\left|A\right|$
\end_inset

 azioni e 
\begin_inset Formula $m=\left|A\right|$
\end_inset

 proprietà (ogni azione genera una e una sola proprietà)
\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|P_{j}\right|\leq m,\,\forall j\in\left\{ 1,\ldots,k\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\left|A_{j}\right|\leq n,\,\forall j\in\left\{ 1,\ldots,k\right\} $
\end_inset


\end_layout

\begin_layout Itemize
gli algoritmi per generare ogni livello sono polinomiali nella dimensione
 del problema
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Bibliography"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
