#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass scrbook
\begin_preamble
% increases link area for cross-references and autoname them
% if you change the document language to e.g. French
% you must change "extrasenglish" to "extrasfrench"
\AtBeginDocument{%
 \renewcommand{\ref}[1]{\mbox{\autoref{#1}}}
}
\def\refnamechanges{%
 \renewcommand*{\equationautorefname}[1]{}%
 \renewcommand{\sectionautorefname}{\negthinspace}%
 \renewcommand{\subsectionautorefname}{\negthinspace}%
 \renewcommand{\subsubsectionautorefname}{\negthinspace}%
 \renewcommand{\figureautorefname}{Fig.\negthinspace}%
 \renewcommand{\tableautorefname}{Tab.\negthinspace}%
}
\@ifpackageloaded{babel}{\addto\extrasitalian{\refnamechanges}}{\refnamechanges}

% in case somebody want to have the label "Equation"
%\renewcommand{\eqref}[1]{Equation~(\negthinspace\autoref{#1})}

% that links to image floats jumps to the beginning
% of the float and not to its caption
\usepackage[figure]{hypcap}

% the pages of the TOC is numbered roman
% and a pdf-bookmark for the TOC is added
\let\myTOC\tableofcontents
\renewcommand\tableofcontents{%
  \frontmatter
  \pdfbookmark[1]{\contentsname}{}
  \myTOC
  \mainmatter }

% makes caption labels bold
% for more info about these settings, see
% http://mirrors.ctan.org/macros/latex/contrib/koma-script/doc/scrguien.pdf
\setkomafont{captionlabel}{\bfseries}
\setcapindent{1em}

% enables calculations
\usepackage{calc}

% fancy page header/footer settings
% for more information see section 9 of
% ftp://www.ctan.org/pub/tex-archive/macros/latex2e/contrib/fancyhdr/fancyhdr.pdf
\renewcommand{\chaptermark}[1]{\markboth{#1}{#1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% increases the bottom float placement fraction
\renewcommand{\bottomfraction}{0.5}

% avoids that floats are placed above its sections
\let\mySection\section\renewcommand{\section}{\suppressfloats[t]\mySection}
\end_preamble
\options intoc,bibliography=totoc,index=totoc,BCOR10mm,captions=tableheading,titlepage
\use_default_options true
\master thesis.lyx
\begin_modules
customHeadersFooters
theorems-ams-bytype
theorems-chap-bytype
\end_modules
\maintain_unincluded_children false
\language italian
\language_package default
\inputencoding auto
\fontencoding global
\font_roman lmodern
\font_sans lmss
\font_typewriter lmtt
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format pdf2
\output_sync 0
\bibtex_command bibtex
\index_command default
\float_placement h
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_title "Documento > Proprietà PDF > Generale"
\pdf_author "Francesco Marano"
\pdf_bookmarks true
\pdf_bookmarksnumbered true
\pdf_bookmarksopen true
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle false
\pdf_quoted_options "pdfpagelayout=OneColumn, pdfnewwindow=true, pdfstartview=XYZ, plainpages=false"
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 0
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 0
\use_package mhchem 1
\use_package stackrel 0
\use_package stmaryrd 0
\use_package undertilde 0
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\branch NoChildDocument
\selected 0
\filename_suffix 0
\color #ff0000
\end_branch
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language french
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes true
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Left Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
chaptername
\end_layout

\end_inset


\begin_inset space ~
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thechapter
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
rightmark
\end_layout

\end_inset


\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
Enable page headers and add the chapter to the header line.
\end_layout

\end_inset


\end_layout

\begin_layout Right Header
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
leftmark
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Left Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Center Footer

\end_layout

\begin_layout Right Footer
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
thepage
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Algoritmo di pianificazione
\end_layout

\begin_layout Standard
In questo capitolo verranno presentati in dettaglio i diversi elementi che
 permettono di rappresentare un problema di pianificazione rispetto al mondo
 presentato.
 Per raggiungere questo risultato e automatizzare il processo di ricerca
 della soluzione, è stato sviluppato un nuovo algoritmo sulla base del ben
 più noto algoritmo di pianificazione GraphPlan 
\begin_inset CommandInset citation
LatexCommand cite
key "wiki:GraphPlan"

\end_inset

, sviluppato da Avrim Blum e Merrick Furst nel 1995, di cui costituisce
 un rilassamento.
\end_layout

\begin_layout Standard
Chiameremo questo algoritmo RGP
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "RGP"
description "Relaxed GraphPlan"

\end_inset

 da 
\shape italic

\begin_inset Quotes fld
\end_inset

Relaxed GraphPlan
\shape default

\begin_inset Quotes frd
\end_inset

.
\end_layout

\begin_layout Section
Relaxed GraphPlan
\begin_inset CommandInset label
LatexCommand label
name "sec:relaxed-graphplan"

\end_inset


\end_layout

\begin_layout Standard
RGP è un algoritmo di pianificazione per la ricerca automatica di pattern
 di esecuzione dei componenti al fine di raggiungere lo stato finale specificato.
\end_layout

\begin_layout Standard
L'algoritmo riceve in input un problema di pianificazione espresso in forma
 di insieme di proprietà iniziali e proprietà finali e produce, laddove
 possibile, una sequenza di azioni la cui esecuzione porta al raggiungimento
 dello stato finale.
\end_layout

\begin_layout Standard
Nel grafo risultante dalla costruzione di un'istanza del problema:
\end_layout

\begin_layout Itemize
i nodi sono proprietà e azioni eseguibili, disposte in un'alternanza di
 livelli
\end_layout

\begin_layout Itemize
gli archi sono di due tipi:
\end_layout

\begin_deeper
\begin_layout Itemize
da una proprietà alle azioni di cui è precondizione,
\end_layout

\begin_layout Itemize
da un'azione alla proprietà che ha come postcondizione.
\end_layout

\end_deeper
\begin_layout Standard
Il primo livello contiene le proprietà che identificano lo stato iniziale
 che può eventualmente essere vuoto.
 L'ultimo livello contiene le proprietà che identificano lo stato finale.
\end_layout

\begin_layout Standard
L'algoritmo iterativamente espande il grafo, verificando che non sia già
 stato raggiunto lo stato finale prima di procedere; durante l'espansione
 RGP cerca, sulla base delle proprietà fino a quel momento ottenute, tutte
 quelle proprietà le cui precondizioni risultano soddisfatte, e che non
 siano già state inserite nel grado, e le utilizza per costruire il livello
 successivo.
\end_layout

\begin_layout Subsection
Istanza del problema
\begin_inset CommandInset label
LatexCommand label
name "sec:istanza-del-problema"

\end_inset


\end_layout

\begin_layout Standard
In RGP un'istanza del problema è una tripla 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $A$
\end_inset

 è l'insieme delle azioni
\end_layout

\begin_layout Itemize
\begin_inset Formula $s_{i}$
\end_inset

 è l'insieme delle proprietà che costituiscono lo stato iniziale
\end_layout

\begin_layout Itemize
\begin_inset Formula $g$
\end_inset

 è l'insieme delle proprietà che costituiscono lo stato finale
\end_layout

\begin_layout Subsection
Grafo di pianificazione
\begin_inset CommandInset label
LatexCommand label
name "sec:grafo-di-pianificazione"

\end_inset


\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 un'istanza di RGP, allora 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 è il corrispondente grafo di pianificazione, dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V=P_{0}\cup A_{1}\cup P_{1}\cup\ldots\cup A_{n}\cup P_{n}$
\end_inset

 con:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $P_{0}\equiv s_{i}$
\end_inset

, lo stato iniziale
\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{n}\equiv g$
\end_inset

, lo stato finale
\end_layout

\begin_layout Itemize
\begin_inset Formula $P_{i}=\left\{ p\colon p\in P_{i-1}\right\} \cup\left\{ p\colon\exists a\in A_{i}\left[p=postcondition(a)\right]\right\} $
\end_inset

, l'insieme delle proprietà al livello 
\begin_inset Formula $i$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $A_{j}=\left\{ a\colon preconditions(a)\subseteq P_{j-1}\right\} $
\end_inset

, l'insieme delle azioni al livello 
\begin_inset Formula $j$
\end_inset


\end_layout

\end_deeper
\begin_layout Itemize
\begin_inset Formula $E=E_{pre}\cup E_{post}$
\end_inset

 con:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $E_{pre}=\left\{ (p,a)\colon p\in P_{i-1},a\in A_{i}\left[p\in preconditions(a)\right]\right\} $
\end_inset

 per 
\begin_inset Formula $i\in\left\{ 1,\ldots,n\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{post}=\left\{ (a,p)\colon a\in A_{i},p\in P_{i}\left[p=postcondition(a)\right]\right\} $
\end_inset

 per 
\begin_inset Formula $i\in\left\{ 1,\ldots,n\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Proposition
Ad ogni passo dell'algoritmo deve essere vero che, comunque presi due indici
 
\begin_inset Formula $i$
\end_inset

 e 
\begin_inset Formula $j$
\end_inset

 tali che 
\begin_inset Formula $i\neq j$
\end_inset

 e 
\begin_inset Formula $i,j<n$
\end_inset

, allora 
\begin_inset Formula $a\in A_{i}\implies a\notin A_{j}$
\end_inset

.
\end_layout

\begin_layout Definition
Il risultato dell'applicazione dell'insieme di azioni 
\begin_inset Formula $\alpha$
\end_inset

 allo stato 
\begin_inset Formula $s$
\end_inset

 è definito come:
\begin_inset Formula 
\[
\rho\left(s,\alpha\right)=s\cup postconditions\left(\alpha\right)
\]

\end_inset

 dove:
\begin_inset Formula 
\[
postconditions\left(\alpha\right)=\bigcup_{a\in\alpha}postcondition\left(a\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Remark
Un insieme di azioni 
\begin_inset Formula $\alpha$
\end_inset

 è applicabile a uno stato 
\begin_inset Formula $s$
\end_inset

 se e solo se 
\begin_inset Formula $\bigcup_{a\in\alpha}preconditions(a)\subseteq s$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Proposition
Dato un insieme di azioni 
\begin_inset Formula $\alpha$
\end_inset

 in uno stato 
\begin_inset Formula $s$
\end_inset

 allora, per ogni permutazione 
\begin_inset Formula $\sigma=<a_{1},\ldots,a_{k}>$
\end_inset

 degli elementi di 
\begin_inset Formula $\alpha$
\end_inset

:
\end_layout

\begin_layout Itemize
la sequenza 
\begin_inset Formula $\sigma$
\end_inset

 è applicabile a 
\begin_inset Formula $s$
\end_inset


\end_layout

\begin_layout Itemize
lo stato risultante dall'applicazione di 
\begin_inset Formula $\alpha$
\end_inset

 è lo stesso di quello derivante dall'applicazione di 
\begin_inset Formula $\sigma$
\end_inset

, cioè 
\begin_inset Formula $\rho\left(s,\alpha\right)=\rho\left(s,\sigma\right)$
\end_inset

.
\end_layout

\begin_layout Subsection
Soluzione
\begin_inset CommandInset label
LatexCommand label
name "sec:soluzione"

\end_inset


\end_layout

\begin_layout Standard
Sia 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 un'istanza di RGP e 
\begin_inset Formula $G=\left(V,E\right)$
\end_inset

 il corrispondente grafo di pianificazione.
\end_layout

\begin_layout Proposition
Se 
\begin_inset Formula $g$
\end_inset

 è raggiungibile da 
\begin_inset Formula $s_{i}$
\end_inset

 allora 
\begin_inset Formula $\exists P_{g}\colon g\subseteq P_{g}$
\end_inset


\end_layout

\begin_layout Definition
Due azioni 
\begin_inset Formula $a_{1}$
\end_inset

 e 
\begin_inset Formula $a_{2}$
\end_inset

 sono equivalenti se e solo se 
\begin_inset Formula $postcondition\left(a_{1}\right)=postcondition\left(a_{2}\right)$
\end_inset

.
\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Due azioni 
\begin_inset Formula $a_{1}$
\end_inset

 e 
\begin_inset Formula $a_{2}$
\end_inset

 sono identiche se sono equivalenti e 
\begin_inset Formula $preconditions\left(a_{1}\right)=preconditions\left(a_{2}\right)$
\end_inset


\end_layout

\begin_layout --Separator--

\end_layout

\begin_layout Definition
Un 
\shape italic
layered plan
\shape default
 su 
\begin_inset Formula $G$
\end_inset

 è una sequenza di insiemi di azioni definita come:
\begin_inset Formula 
\[
\Pi=<\pi_{1},\ldots,\pi_{k}>
\]

\end_inset

dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{i}\subseteq A_{i}\subseteq A$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{i}$
\end_inset

 è applicabile nello stato 
\begin_inset Formula $P_{i-1}$
\end_inset


\end_layout

\begin_layout Itemize
le azioni in 
\begin_inset Formula $\pi_{i}$
\end_inset

 sono non-identiche e non-equivalenti
\end_layout

\begin_layout Theorem
Un layered plan 
\begin_inset Formula $\Pi=<\pi_{1},\ldots,\pi_{k}>$
\end_inset

 è una soluzione di un'istanza di RGP 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

 se e solo se:
\end_layout

\begin_layout Itemize
\begin_inset Formula $\pi_{1}$
\end_inset

 è applicabile in 
\begin_inset Formula $s_{i}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $\forall j\in\left\{ 2,\ldots,k\right\} $
\end_inset

 
\begin_inset Formula $\pi_{j}$
\end_inset

 è applicabile nello stato 
\begin_inset Formula $\rho\left(\ldots\rho\left(\rho\left(s_{i},\pi_{1}\right),\pi_{2}\right)\ldots,\pi_{j-1}\right)$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $g\subseteq\rho\left(\ldots\rho\left(\rho\left(s_{i},\pi_{1}\right),\pi_{2}\right)\ldots,\pi_{k}\right)$
\end_inset


\end_layout

\begin_layout Standard
\begin_inset VSpace smallskip
\end_inset


\end_layout

\begin_layout Proposition
Se 
\begin_inset Formula $\Pi=<\pi_{1},\ldots,\pi_{k}>$
\end_inset

 è una soluzione di un'istanza di RGP 
\begin_inset Formula $P=\left(A,s_{i},g\right)$
\end_inset

, allora 
\begin_inset Formula $\forall j\in\left\{ 1,\ldots,k\right\} $
\end_inset

 una sequenza di azioni corrispondenti a qualsiasi permutazione degli elementi
 di 
\begin_inset Formula $\pi_{j}$
\end_inset

 è un percorso da 
\begin_inset Formula $s_{i}$
\end_inset

 a 
\begin_inset Formula $g$
\end_inset

.
\end_layout

\begin_layout Section
Descrizione implementativa
\end_layout

\begin_layout Subsection
Costruzione del grafo di pianificazione
\end_layout

\begin_layout Standard
A partire dallo stato iniziale l'algoritmo iterativamente espande il grafo.
 A ogni passo si possono verificare tre condizioni:
\end_layout

\begin_layout Enumerate
è stato raggiunto lo stato finale.
 L'algoritmo estrae la soluzione dal grafo trovato e termina.
\end_layout

\begin_layout Enumerate
non è stato raggiunto lo stato finale, ma è ancora possibile trovare una
 soluzione.
 L'algoritmo procede espandendo il grafo.
\end_layout

\begin_layout Enumerate
non è stato raggiunto lo stato finale e non è possibile farlo tramite ulteriori
 espansioni.
 L'algoritmo termina in uno stato di 
\shape italic
failure
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
costruzione del grafo di pianificazione
\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
function
\series default
 RelaxedGraphPlan(
\begin_inset Formula $A$
\end_inset

,
\begin_inset Formula $s_{i}$
\end_inset

,
\begin_inset Formula $g$
\end_inset

)
\end_layout

\begin_layout LyX-Code

\series bold
returns
\series default
 LayeredPlan, or failure
\end_layout

\begin_deeper
\begin_layout LyX-Code
graph 
\begin_inset Formula $\leftarrow$
\end_inset

 initialPlanningGraph(
\begin_inset Formula $s_{i}$
\end_inset

)
\end_layout

\begin_layout LyX-Code
goals 
\begin_inset Formula $\leftarrow$
\end_inset

 
\begin_inset Formula $g$
\end_inset


\end_layout

\begin_layout LyX-Code
\noindent

\series bold
loop do
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\noindent

\series bold
if
\series default
 goals all in last property layer of graph 
\series bold
then
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
return
\series default
 LayeredPlan(graph)
\end_layout

\end_deeper
\begin_layout LyX-Code

\series bold
else if
\series default
 noSolutionPossible(graph) 
\series bold
then
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
return
\series default
 failure
\end_layout

\end_deeper
\begin_layout LyX-Code

\series bold
else
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\paragraph_spacing single
\noindent
graph 
\begin_inset Formula $\leftarrow$
\end_inset

 expand(graph, 
\begin_inset Formula $A$
\end_inset

)
\end_layout

\end_deeper
\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Subsection
Espansione del grafo
\end_layout

\begin_layout Definition
Indichiamo con 
\begin_inset Formula $G_{k}=\left(V_{k},E_{k}\right)$
\end_inset

 il grafo di pianificazione ottenuto al passo 
\begin_inset Formula $k$
\end_inset

, dove:
\end_layout

\begin_layout Itemize
\begin_inset Formula $V_{k}=P_{0}\cup P_{1}\cup A_{1}\cup\ldots\cup P_{k}\cup A_{k}$
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{k}=E_{pre}^{k}\cup E_{post}^{k}$
\end_inset

 con:
\end_layout

\begin_deeper
\begin_layout Itemize
\begin_inset Formula $E_{pre}^{k}=\left\{ (p,a)\colon p\in P_{k-1},a\in A_{k}\left[p\in preconditions(a)\right]\right\} $
\end_inset


\end_layout

\begin_layout Itemize
\begin_inset Formula $E_{post}^{k}=\left\{ (a,p)\colon a\in A_{k},p\in P_{k}\left[p=postcondition(a)\right]\right\} $
\end_inset


\end_layout

\end_deeper
\begin_layout Standard
\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout Standard
In un generico istante 
\begin_inset Formula $k$
\end_inset

 l'algoritmo di espansione del grafo di pianificazione trova prima di tutto
 l'insieme 
\begin_inset Formula $A_{k}$
\end_inset

 delle azioni, che non facciano già parte di alcun livello precedente, le
 cui precondizioni risultino soddisfatte dalle proprietà fino a quel momento
 ottenute.
\end_layout

\begin_layout Standard
A partire da queste si ottiene il livello delle proprietà 
\begin_inset Formula $P_{k}$
\end_inset

 successivo costituito di tutte le proprietà del livello precedente più
 quelle ottenute dalle postcondizioni delle azioni in 
\begin_inset Formula $A_{k}$
\end_inset

.
\end_layout

\begin_layout Standard
A questo punto viene completato il grafo inserendo gli archi tra le proprietà
 del livello precedente verso le azioni che le richiedono come precondizioni,
 e quelli tra le azioni del livello attuale verso le proprietà che hanno
 come postcondizioni.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
espansione del grafo di pianificazione
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
function
\series default
 expand(
\begin_inset Formula $G_{k-1}$
\end_inset

,
\begin_inset Formula $A$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $A_{k}\leftarrow\left\{ a\in A\colon a\notin A_{j=1,\ldots,k-1}\land preconditions\left(a\right)\subseteq P_{k-1}\right\} $
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $P_{k}\leftarrow\left\{ p\colon\exists a\in A_{k}\left[p=postcondition\left(a\right)\right]\right\} \cup P_{k-1}$
\end_inset


\end_layout

\begin_layout LyX-Code
foreach 
\begin_inset Formula $a$
\end_inset

 in 
\begin_inset Formula $A_{k}$
\end_inset

 do:
\end_layout

\begin_deeper
\begin_layout LyX-Code

\series bold
\size small
\begin_inset Formula $E_{pre}^{k}\leftarrow E_{pre}^{k-1}\cup\left\{ \left(p,a\right)\colon p\in P_{k-1}\land p\in preconditions\left(a\right)\right\} $
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
\size small
\begin_inset Formula $E_{post}^{k}\leftarrow E_{post}^{k-1}\cup\left\{ \left(a,p\right)\colon p\in P_{k}\land p=postcondition\left(a\right)\right\} $
\end_inset


\end_layout

\end_deeper
\end_deeper
\end_inset


\end_layout

\begin_layout Subsection
Estrazione della soluzione
\end_layout

\begin_layout Standard
L'estrazione della soluzione procede iterativamente dall'ultimo verso il
 primo dei livelli del grafo di pianificazione.
 A ogni passo 
\begin_inset Formula $i$
\end_inset

, trova un insieme di azioni 
\begin_inset Formula $\alpha_{i}\subseteq A_{i}$
\end_inset

 tali che lo stato finale 
\begin_inset Formula $g$
\end_inset

 sia soddisfatto, cioè 
\begin_inset Formula $\bigcup_{a\in\alpha_{i}}postcondition\left(a\right)=g$
\end_inset

, e si inseriscono nella soluzione.
\end_layout

\begin_layout Standard
A questo punto si prende l'unione di tutte le precondizioni delle azioni
 scelte e si imposta come nuovo stato finale, cioè 
\begin_inset Formula $g=\bigcup_{a\in\alpha_{i}}preconditions\left(a\right)$
\end_inset

, e si procede con il prossimo livello.
\end_layout

\begin_layout Standard
Raggiunto il primo livello (lo stato iniziale), l'algoritmo termina restituendo
 la soluzione.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
estrazione della soluzione
\end_layout

\end_inset


\begin_inset VSpace medskip
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
function
\series default
 LayeredPlan(planning graph 
\begin_inset Formula $G$
\end_inset

, goal state 
\begin_inset Formula $g$
\end_inset

)
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $solution$
\end_inset

 
\begin_inset Formula $\leftarrow$
\end_inset

 
\begin_inset Formula $\emptyset$
\end_inset


\end_layout

\begin_layout LyX-Code

\series bold
for
\series default
 
\begin_inset Formula $i=\left|G\right|$
\end_inset

 
\series bold
to
\series default
 
\begin_inset Formula $1$
\end_inset

 
\series bold
do
\series default
:
\end_layout

\begin_deeper
\begin_layout LyX-Code
\begin_inset Formula $\alpha_{i}\leftarrow\left\{ a\colon a\in A_{i}\land postcondition\left(a\right)\in g\right\} $
\end_inset


\end_layout

\begin_layout LyX-Code
prepend 
\begin_inset Formula $\alpha_{i}$
\end_inset

 to 
\begin_inset Formula $solution$
\end_inset


\end_layout

\begin_layout LyX-Code
\begin_inset Formula $g\leftarrow\bigcup_{a\in\alpha_{i}}preconditions\left(a\right)$
\end_inset


\end_layout

\end_deeper
\begin_layout LyX-Code

\series bold
return
\series default
 
\begin_inset Formula $solution$
\end_inset


\end_layout

\end_deeper
\end_inset


\end_layout
\begin_inset Branch NoChildDocument
status collapsed

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "Bibliography"
options "alpha"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset nomencl_print
LatexCommand printnomenclature
set_width "custom"
width "2.5cm"

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
